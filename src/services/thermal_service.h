#pragma once
#include <cmath>
#include <mutex>

#include "autonomous_msgs.h"
#include "component.h"
#include "component_logger.h"
#include "core_msgs.h"
#include "message_bus.h"
#include "simulation_msgs.h"

namespace sil {

class DOC_DESC(
    "Simulates basic motor and battery temperature dynamics.\n\n"
    "On each physics tick, the service updates motor and battery temperatures using a simple "
    "first-order heat balance: a speed-proportional heat generation term minus a linear cooling "
    "term to ambient. Ambient temperature is updated from EnvironmentData. A ThermalRequest "
    "publishes the latest temperatures.\n\n"
    "Motor model:\n"
    "$$ \\dot{T}_m = q_m - c_m \\,(T_m - T_a) $$\n"
    "$$ q_m = 0.005\\,|\\mathrm{RPM}|,\\quad c_m = 0.05 $$\n\n"
    "Battery model:\n"
    "$$ \\dot{T}_b = q_b - c_b \\,(T_b - T_a) $$\n"
    "$$ q_b = 0.002\\,|\\mathrm{RPM}|,\\quad c_b = 0.02 $$\n\n"
    "Discrete update per tick (for each body):\n"
    "$$ T \\leftarrow T + \\bigl(\\dot{T}\\bigr)\\,\\Delta t $$\n\n"
    "Where $T_a$ is ambient temperature from EnvironmentData, and $\\Delta t$ is the physics "
    "timestep in seconds.")
ThermalService {
 public:
  using Subscribes =
      ipc::MsgList<MsgId::PhysicsTick, MsgId::EnvironmentData, MsgId::ThermalRequest>;
  using Publishes = ipc::MsgList<MsgId::ThermalData>;

  explicit ThermalService(ipc::MessageBus& bus) : bus_(bus), logger_("thermal") {
    ipc::bind_subscriptions(bus_, this);
  }

  void on_message(const PhysicsTickPayload& tick) {
    std::lock_guard lk{mu_};
    float dt_s = tick.dt_us / 1e6f;

    // Heat generated by motor based on RPM
    float motor_heat_rate = std::abs(tick.speed_rpm) * 0.005f;
    // Heat dissipated to environment
    float motor_cooling_rate = (motor_temp_c_ - ambient_temp_c_) * 0.05f;

    motor_temp_c_ += (motor_heat_rate - motor_cooling_rate) * dt_s;

    // Battery heat generated by current draw (simplistic approx based on RPM)
    float battery_heat_rate = std::abs(tick.speed_rpm) * 0.002f;
    float battery_cooling_rate = (battery_temp_c_ - ambient_temp_c_) * 0.02f;

    battery_temp_c_ += (battery_heat_rate - battery_cooling_rate) * dt_s;

    static uint32_t count = 0;
    if (++count % 100 == 0) {
      logger_.info("Motor Temp: %.1fC, Battery Temp: %.1fC", motor_temp_c_, battery_temp_c_);
    }
  }

  void on_message(const EnvironmentPayload& env) {
    std::lock_guard lk{mu_};
    ambient_temp_c_ = env.ambient_temp_c;
  }

  void on_message(const ThermalRequestPayload&) {
    ThermalPayload p{};
    {
      std::lock_guard lk{mu_};
      p.motor_temp_c = motor_temp_c_;
      p.battery_temp_c = battery_temp_c_;
    }
    bus_.publish<MsgId::ThermalData>(p);
  }

 private:
  void publish_data() {
    ThermalPayload p{};
    {
      std::lock_guard lk{mu_};
      p.motor_temp_c = motor_temp_c_;
      p.battery_temp_c = battery_temp_c_;
    }
    bus_.publish<MsgId::ThermalData>(p);
  }

 private:
  ipc::MessageBus& bus_;
  ComponentLogger logger_;
  std::mutex mu_;

  float ambient_temp_c_{20.0f};
  float motor_temp_c_{20.0f};
  float battery_temp_c_{20.0f};
};

}  // namespace sil
