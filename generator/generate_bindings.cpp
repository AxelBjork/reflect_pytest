#include <fstream>
#include <functional>
#include <iostream>
#include <string>
#include <string_view>

#include "python_code_generator.h"

template <typename T>
void hash_combine(std::size_t& seed, const T& v) {
  std::hash<T> hasher;
  seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

int main(int argc, char** argv) {
  if (argc != 2) {
    std::cerr << "Usage: generate_bindings <output_revision_header_path>\n";
    return 1;
  }
  std::string revision_header_path = argv[1];
  std::cout << "\"\"\"Auto-generated IPC bindings using C++26 static reflection.\"\"\"\n\n";
  std::cout << "import struct\n";
  std::cout << "from dataclasses import dataclass\n";
  std::cout << "from enum import IntEnum\n\n";

  // ── Enums ──────────────────────────────────────────────────────────────────
  generate_enum<MsgId>();
  generate_enum<Severity>();
  generate_enum<SystemState>();
  generate_enum<::DriveMode>();

  // ── Helper structs (not top-level messages) ────────────────────────────────
  std::set<std::string> visited;
  generate_struct<::MotorSubCmd>(visited);

  // ── Message payload structs ────────────────────────────────────────────────
  constexpr std::size_t num_msgs = get_enum_size<MsgId>();
  [&]<std::size_t... Is>(std::index_sequence<Is...>) {
    (..., [&] {
      constexpr auto e = EnumArrHolder<MsgId, num_msgs>::arr[Is];
      constexpr uint32_t val = static_cast<uint32_t>([:e:]);
      generate_struct_for_msg_id<val>(visited);
    }());
  }(std::make_index_sequence<num_msgs>{});

  std::cout << "MESSAGE_BY_ID = {\n";
  [&]<std::size_t... Is>(std::index_sequence<Is...>) {
    (..., [] {
      constexpr auto e = EnumArrHolder<MsgId, num_msgs>::arr[Is];
      constexpr uint32_t val = static_cast<uint32_t>([:e:]);
      emit_metadata_for_msg_id<val>();
    }());
  }(std::make_index_sequence<num_msgs>{});
  std::cout << "}\n\n";

  std::cout << "PAYLOAD_SIZE_BY_ID = {\n";
  [&]<std::size_t... Is>(std::index_sequence<Is...>) {
    (..., [] {
      constexpr auto e = EnumArrHolder<MsgId, num_msgs>::arr[Is];
      constexpr uint32_t val = static_cast<uint32_t>([:e:]);
      emit_size_for_msg_id<val>();
    }());
  }(std::make_index_sequence<num_msgs>{});
  std::cout << "}\n\n";

  std::size_t structural_hash = 0;
  constexpr auto msgid_name = std::meta::identifier_of(^^MsgId);
  hash_combine(structural_hash, std::string_view(msgid_name));

  [&]<std::size_t... Is>(std::index_sequence<Is...>) {
    (..., [&] {
      constexpr auto e = EnumArrHolder<MsgId, num_msgs>::arr[Is];
      constexpr uint32_t val = static_cast<uint32_t>([:e:]);
      std::string_view name = std::meta::identifier_of(e);
      hash_combine(structural_hash, name);

      std::string val_str = std::to_string(val);
      hash_combine(structural_hash, val_str);

      using T = typename payload_or_void<val>::type;
      if constexpr (!std::is_void_v<T>) {
        std::string size_str = std::to_string(sizeof(T));
        hash_combine(structural_hash, size_str);
      }
    }());
  }(std::make_index_sequence<num_msgs>{});

  char hex_string[17];
  snprintf(hex_string, sizeof(hex_string), "%016lx", structural_hash);

  std::cout << "PROTOCOL_HASH = \"" << hex_string << "\"\n\n";

  std::ofstream cpp_out(revision_header_path);
  if (!cpp_out) {
    std::cerr << "Failed to open revision header file for writing: " << revision_header_path
              << std::endl;
    return 1;
  }
  cpp_out << "// Auto-generated by generator/generate_bindings.cpp\n";
  cpp_out << "#pragma once\n\n";
  cpp_out << "#define PROTOCOL_HASH \"" << hex_string << "\"\n";
  cpp_out.close();

  return 0;
}
